Type parameterization allows you to write generic classes and traits. For example, sets are generic and take a type
parameter: they are defined as Set[T]. As a result, any particular set instance might be a Set[String], a Set[Int],
etc., but it must be a set of something. Unlike Java, which allows raw types, Scala requires that you specify type
parameters. Variance defines inheritance relationships of parameterized types, such as whether a Set[String],
for example, is a subtype of Set[AnyRef].

===== VARIANCE ANNOTATIONS
Queue, as defined is a trait, but not a type. Queue is not a type because it takes a type parameter
 def doesNotCompile(q: Queue) = {}
 def doesCompile(q: Queue[AnyRef]) = {}
Thus, Queue is a trait and Queue[String] is a type. Queue is also called a type constructor because you can
construct a type with it by specifying a type parameter.

The combination of type parameters and subtyping poses some interesting questions. For example, are there any
special subtyping relationships between members of the family of types generated by Queue[T]?
Or more generally, if S is a subtype of type T, then should Queue[S] be considered a subtype of Queue[T]?
 * If so, you could say that trait Queue is _covariant_ (or "flexible") in its type parameter T.

Covariant Queues would mean, for example, that you could pass a Queue[String] to the doesCompile method shown previously,
which takes a value parameter of type Queue[AnyRef]

Intuitively, all this seems OK, since a queue of Strings looks like a special case of a queue of AnyRefs.
 * In Scala, however, generic types have by default _nonvariant_ (or "rigid") subtyping

That is, with queues with different element types would never be in a subtype relationship. A Queue[String]
would not be usable as a Queue[AnyRef]. However, you can demand covariant (flexible) subtyping of queues by changing
the first line of the definition of class Queue like this
     trait Queue[+T] { ... }
Prefixing a formal type parameter with a + indicates that subtyping is covariant (flexible) in that parameter.
By adding this single character, you are telling Scala that you want Queue[String], for example, to be considered
a subtype of Queue[AnyRef]. The compiler will check that Queue is defined in a way that this subtyping is sound.

 * there is also a prefix -, which indicates _contravariant_ subtyping. If Queue were defined like this:
    trait Queue[-T] { ... }
Then if T is a subtype of type S, this would imply that Queue[S] is a subtype of Queue[T] (which in the case of queues
would be rather surprising!).

Whether a type parameter is covariant, contravariant, or nonvariant is called the
parameter's variance. The + and - symbols you can place next to type parameters are called variance annotations.


//------------------
To verify correctness of variance annotations, the Scala compiler classifies all positions in a class or trait body as
positive, negative or neutral. A "position" is any location in the class or trait (but from now on we'll just write "class")
body where a type parameter may be used. For example, every method value parameter is a position because a method value
parameter has a type. Therefore a type parameter could appear in that position.

The compiler checks each use of each of the class's type parameters. Type parameters annotated with + may only be used
in positive positions, while type parameters annotated with - may only be used in negative positions. A type parameter
with no variance annotation may be used in any position, and is, therefore, the only kind of type parameter that can
be used in neutral positions of the class body.

To classify the positions, the compiler starts from the declaration of a type parameter and then moves inward through
deeper nesting levels. Positions at the top level of the declaring class are classified as positive. By default,
positions at deeper nesting levels are classified the same as that at enclosing levels, but there are a handful of
exceptions where the classification changes. Method value parameter positions are classified to the flipped classification
relative to positions outside the method, where the flip of a positive classification is negative, the flip of a negative
classification is positive, and the flip of a neutral classification is still neutral.

Besides method value parameter positions, the current classification is also flipped at the type parameters of methods.
A classification is sometimes flipped at the type argument position of a type, such as the Arg in C[Arg], depending on
the variance of the corresponding type parameter. If C's type parameter is annotated with a + then the classification
stays the same. If C's type parameter is annotated with a -, then the current classification is flipped. If C's type
parameter has no variance annotation then the current classification is changed to neutral.

As a somewhat contrived example, consider the following class definition, where several positions are annotated with
their classifications, ^+ (for positive) or ^- (for negative):
    abstract class Cat[-T, +U] {
        def meow[W^-](volume: T^-, listener: Cat[U^+, T^-]^-)
            : Cat[Cat[U^+, T^-]^-, U^+]^+
    }
The positions of the type parameter, W, and the two value parameters, volume and listener, are all negative.
Looking at the result type of meow, the position of the first Cat[U, T] argument is negative because Cat's first type
parameter, T, is annotated with a -. The type U inside this argument is again in positive position (two flips), whereas
the type T inside that argument is still in negative position.