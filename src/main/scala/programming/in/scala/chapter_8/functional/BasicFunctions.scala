package programming.in.scala.chapter_8.functional

/**
  * Created by denis.shuvalov on 08/03/2018.
  */
object BasicFunctions extends App {
//  function literal:
//      A function with no name in Scala source code, specified with function literal syntax. For example, (x: Int, y: Int) => x + y.

//  function value:
//        A function object that can be invoked just like any other function. A function value's class extends one
//        of the FunctionN traits (e.g., Function0, Function1) from package scala, and is usually expressed in source
//        code via function literal syntax. A function value is "invoked" when its apply method is called.
//        A function value that captures free variables is a closure.

  //Function values are objects, so you can store them in variables if you like.
  var increase = (x: Int) => x + 1 //Int => Int = <function1>
  println(increase(10))

  println("--------------------------------------------")
  val someNumbers = List(-11, -10, -5, 0, 5, 10)

  //The Scala compiler knows that x must be an integer, because it sees that you are immediately using the function to
  //filter a list of integers (referred to by someNumbers). This is called target typing because the targeted
  //usage of an expression
  someNumbers.filter(x => x > 0)

  println("--------------------------------------------")
  //Placeholder syntax
  someNumbers.filter(_ > 0)

  //Sometimes when you use underscores as placeholders for parameters, the compiler might not have enough
  //information to infer missing parameter types.
/*  val f = _ + _
    error: missing parameter type for expanded
      function ((x$1, x$2) => x$1.$plus(x$2))
 */
  //In such cases, you can specify the types using a colon, like this:
  val f = (_: Int) + (_: Int)

  println("--------------------------------------------")
  //Partially applied functions

  //replace entire parameter as underscore
  someNumbers.foreach(println _)
  //someNumbers.foreach(x => println(x))

  def sum(a: Int, b: Int, c: Int) = a + b + c
  //A partially applied function is an expression in which you don't supply all of the arguments needed by the function
  val a = sum _ //a: (Int, Int, Int) => Int = <function3>
  println(a(1, 2, 3)) //Int 6

  /*
  Here's what just happened: The variable named a refers to a function value object. This function value is an instance
  of a class generated automatically by the Scala compiler from sum _, the partially applied function expression. The
  class generated by the compiler has an apply method that takes three arguments. The generated class's apply method
  takes three arguments because three is the number of arguments missing in the sum _ expression. The Scala compiler
  translates the expression a(1, 2, 3) into an invocation of the function value's apply method, passing in the three
  arguments 1, 2, and 3. Thus, a(1, 2, 3) is a short form for:

    scala> a.apply(1, 2, 3)
    res12: Int = 6
   */

  //if you have a local function, such as sum(a: Int, b: Int, c: Int): Int, you can "wrap" it in a function value
  //whose apply method has the same parameter list and result types.

  println("--------------------------------------------")
//  Now, although sum _ is indeed a partially applied function, it may not be obvious to you why it is called this. It
//  has this name because you are not applying that function to all of its arguments. In the case of sum _, you are
//  applying it to none of its arguments. But you can also express a partially applied function by supplying only
//  some of the required arguments. Here's an example:
  val b = sum(1, _: Int, 3)
  //In this case, b.apply invoked sum(1, 2, 3)
  b(2) // res = 6
}
